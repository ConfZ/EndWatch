/*
Commit Number: 2.16rc0
URL: https://bugzilla.nasm.us/show_bug.cgi?id=3392790
Project Name: nasm
termination: FALSE
*/
enum token_type {
    TOKEN_EOS = 0,
    TOKEN_PASTE=1,
    TOKEN_WHITESPACE=2,
    TOKEN_FREE=3,

};

typedef struct token{
    struct token *next;
    enum token_type type;
    unsigned int len;
} Token;

static Token *freeTokens  = 0;
static inline enum token_type tok_type(const Token *x)
{
    return x ? x->type : TOKEN_EOS;
}
static inline _Bool tok_is(const Token *x, enum token_type t)
{
    return tok_type(x) == t;
}
static Token *delete_Token(Token *t)
{
    Token *next;

    __VERIFIER_assert(t && t->type != TOKEN_FREE);

    next = t->next;
//    nasm_zero(*t);
    t->type = TOKEN_FREE;
    t->next = freeTokens;
    freeTokens = t;

    return next;
}

static inline _Bool tok_white(const Token *x)
{
    return tok_is(x, TOKEN_WHITESPACE);
}

static Token *zap_white(Token *x)
{
    while (tok_white(x))
        x = delete_Token(x);

    return x;
}

Token ** initLink(int n){
    Token* head=(Token*)malloc(sizeof(Token));
    head->len = __VERIFIER_nondet_int();
    unsigned int tty = __VERIFIER_nondet_int();
    head->type = tty %3;
    Token* cyclic=head;
    int i;
    for (i=2; i<=n; i++) {
        Token * body=(Token*)malloc(sizeof(Token));
        body->next=0;
        cyclic->next=body;
        cyclic=cyclic->next;
    }
    cyclic->next=head;
    return (&head);
}

int main(){

    Token *tok, *t, *next, **prev_next, **prev_nonspace, **nextp;
    unsigned int mnum = __VERIFIER_nondet_uint();
    _Bool handle_explicit = __VERIFIER_nondet_bool();
    int n = __VERIFIER_nondet_int();
    Token** head = initLink(n);
    _Bool pasted = 0;
    unsigned int i;
    tok = *head;
    prev_next = prev_nonspace = head;
    if (tok_white(tok) || tok_is(tok, TOKEN_PASTE))
        prev_nonspace = 0;


    while (tok && (next = tok->next)) {
        _Bool did_paste = 1;
        switch (tok->type) {
            case TOKEN_WHITESPACE:
                tok->next = next = zap_white(next);
                break;
            case TOKEN_PASTE:
                if (!handle_explicit)
                    break;
                did_paste = 1;
                if (!prev_nonspace) {
                    prev_next = nextp = head;
                    t = 0;
                } else {
                    prev_next = prev_nonspace;
                    t = *prev_next;
                    nextp = &t->next;
                }
                next = *nextp;
                while (next) {
                    if (next->type == TOKEN_PASTE || next->type == TOKEN_WHITESPACE)
                        next = delete_Token(next);
                    else
                        break;
                }
                *nextp = next;
                if (!next)
                    break;
                if (!t) {
                    *prev_next = tok = next;
                    break;
                } else
                    return 1;
            default:
                if (i >= mnum)
                    break;
                return 1;
        }
        if (did_paste) {
            pasted = 1;
        } else {
            prev_next = &tok->next;
        }
        tok = next;
    }

}
