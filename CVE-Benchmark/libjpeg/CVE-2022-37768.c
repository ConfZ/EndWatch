/*
Commit Number: 14bf94c
URL: https://github.com/thorfdbg/libjpeg/issues/77
Project Name: libjpeg
termination: FALSE
*/
#include <stdlib.h>
#include <assert.h>
#define true 1
#define false 0

enum {
    EOF   = -1
};

typedef struct{
    long* m_pucBufPtr;
    long* m_pucBuffer;
    long* m_pucBufEnd;
}ByteStream;
long get(ByteStream* s){
    return *(s->m_pucBufPtr++);
}
void LastUnDo(ByteStream* s)
{
    assert(s->m_pucBufPtr == NULL || s->m_pucBufPtr > s->m_pucBuffer);
    if (s->m_pucBufPtr > s->m_pucBuffer) {
        s->m_pucBufPtr--;
        return ;
    } else
    return ;
}
long Get(ByteStream* s)                          // read a single byte (inlined)
{
    if (s->m_pucBufPtr >= s->m_pucBufEnd) {
        exit(0);
    }
    return *(s->m_pucBufPtr++);
}
long PeekWord(ByteStream* s){
    long byte1, byte2;
    byte2 = Get(s);
    if (byte1 != EOF){
        byte2 = Get(s);
        if (byte2 != EOF) {
            LastUnDo(s);
            if (s->m_pucBufPtr>s->m_pucBuffer) {
                LastUnDo(s);
            }else{
                exit(0);
            }
            return ((byte1<<8) | byte2);

        }
        exit(0);
    }
    return EOF;
}


int main(){

    ByteStream * io = (ByteStream*) malloc (sizeof(ByteStream));

    io->m_pucBuffer = (long*) malloc(sizeof(long));
    io->m_pucBufPtr = (long*) malloc(sizeof(long)*5);
    io->m_pucBufEnd = (long*) malloc(sizeof(long));

    for (int i = 0; i < 5; ++i) {
        *(io->m_pucBufPtr+i) = 255;
    }
//    *(io->m_pucBufPtr) = 255;
    *(io->m_pucBuffer) = 218;
    *(io->m_pucBufEnd) = 240;

    do {
        long marker = PeekWord(io);
//        class DataBox *box;

        switch(marker) {
            case 0xffb1:
            case 0xffb2:
            case 0xffb3:
            case 0xffb9:
            case 0xffba:
            case 0xffbb:
            case 0xffc0:
            case 0xffc1:
            case 0xffc2:
            case 0xffc3:
            case 0xffc9:
            case 0xffca:
            case 0xffcb:
            case 0xfff7:
                return false;
            case 0xffde:
                return false;
            case 0xffc5:
            case 0xffc6:
            case 0xffc7:
            case 0xffcd:
            case 0xffce:
            case 0xffcf:
                return false;
            case 0xffda:
                return true;
            case 0xffd9:
                return false;
            case 0xffff:
                break;
            case 0xffd0:
            case 0xffd1:
            case 0xffd2:
            case 0xffd3:
            case 0xffd4:
            case 0xffd5:
            case 0xffd6:
            case 0xffd7:
                break;
            case EOF:
                return false;
            default:
                if (marker < 0xff00) {
                    exit(1);
                } else {
                    //do nothing
                   }
        }
    } while(true);
}